package com.velocitypowered.proxy.protection;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class PacketExploitChecker extends ChannelDuplexHandler {
    private static final int MAX_PACKET_SIZE = 2097152; // 2MB
    private static final int PACKETS_PER_SECOND_THRESHOLD = 1000;
    private static final Map<String, AtomicInteger> PACKET_COUNTER = new ConcurrentHashMap<>();
    
    // Chặn các loại packet exploit phổ biến
    private static final String[] BLOCKED_PACKETS = {
        // Minecraft exploits
        "MC|BEdit",
        "MC|BSign",
        "MC|ItemName",
        // Known malicious packets
        "WECUI",
        "WDL|INIT",
        "WDL|CONTROL",
        // Forge exploits
        "FML|HS",
        "FML|MP",
        "REGISTER"
    };

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (msg instanceof ByteBuf) {
            ByteBuf buf = (ByteBuf) msg;
            
            // Kiểm tra kích thước packet
            if (buf.readableBytes() > MAX_PACKET_SIZE) {
                ctx.close();
                return;
            }

            // Kiểm tra tốc độ gửi packet
            String address = ctx.channel().remoteAddress().toString();
            AtomicInteger counter = PACKET_COUNTER.computeIfAbsent(address, k -> new AtomicInteger(0));
            
            if (counter.incrementAndGet() > PACKETS_PER_SECOND_THRESHOLD) {
                ctx.close();
                return;
            }

            // Kiểm tra packet độc hại
            byte[] content = new byte[Math.min(buf.readableBytes(), 256)];
            buf.getBytes(buf.readerIndex(), content);
            String packetContent = new String(content);

            for (String blockedPacket : BLOCKED_PACKETS) {
                if (packetContent.contains(blockedPacket)) {
                    ctx.close();
                    return;
                }
            }

            // Kiểm tra NBT data
            if (packetContent.contains("TAG_")) {
                if (!isValidNbt(content)) {
                    ctx.close();
                    return;
                }
            }
        }
        
        super.channelRead(ctx, msg);
    }

    private boolean isValidNbt(byte[] content) {
        // Thêm logic kiểm tra NBT data
        // Chặn các NBT data độc hại
        return true; 
    }

    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        // Kiểm tra packet gửi đi
        if (msg instanceof ByteBuf) {
            ByteBuf buf = (ByteBuf) msg;
            if (buf.readableBytes() > MAX_PACKET_SIZE) {
                ctx.close();
                return;
            }
        }
        super.write(ctx, msg, promise);
    }
}